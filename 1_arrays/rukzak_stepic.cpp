/*
https://stepik.org/lesson/307329/step/6?unit=289417


У вас есть nn слитков золота, каждый имеет свой вес и стоимость. Также у вас есть рюкзак вместимости SS. Необходимо вычислить максимальную суммарную стоимость слитков, которую вы можете получить. Вы можете дробить слитки. В таком случае стоимость слитка будет уменьшаться пропорционально весу слитка.

Входные данные

В первой строке записано два целых числа SS и NN (1 \leq S \leq 10^41≤S≤10 
4
 ; 1 \leq N \leq 3001≤N≤300).

Во второй строке записаны nn целых чисел - веса слитков. Каждый слиток имеет неотрицательный вес, не превосходящий 10^510 
5
 .

В третьей строке записаны еще nn целых чисел - стоимости слитков. Каждый слиток имеет неотрицательную стоимость, не превосходящую 10^510 
5
 .

Выходные данные

Выведите единственное число - максимальную суммарную стоимость, которую вы можете унести. Если ответ получается не целым, округлите его вверх до ближайшего целого.

*/

#include <bits/stdc++.h>

using namespace std;


int main() {
    int s, n;
    cin >> s >> n;
    vector<double>weights(n);
    vector<double>costs(n);
    for (int i = 0; i < n; ++i) {
        cin >> weights[i];
    }
    
    for (int i = 0; i < n; ++i) {
        cin >> costs[i];
    }
  
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            if (costs[i] / weights[i] < costs[j] / weights[j]) {
                std::swap(costs[i], costs[j]);
                std::swap(weights[i], weights[j]);
            }
        }
    }
    double res = 0;
    for (int i = 0; i < n and s > 0; ++i) {
        if (weights[i] > s) {
            res += (s) / weights[i] * costs[i];
            s = 0; 
        } else {
            res += costs[i];
            s -= weights[i];
        }
    }
    cout << (long)ceil(res);
    return 0;
}
