/*
https://stepik.org/lesson/307327/step/3?unit=289415

Поле

Отряду нужно пересечь прямоугольное поле размера m \times nm×n квадратов, двигаясь из левого верхнего угла в правый нижний и перемещаясь между соседними квадратами только в двух направлениях - вправо и вниз. Поле не очень ровное, но у отряда есть карта, на которой отмечена высота каждого квадрата. Опасность перехода с квадрата высоты h_1h 
1
​	
  на соседний квадрат высоты h_2h 
2
​	
  оценивается числом |h_2 - h_1|∣h 
2
​	
 −h 
1
​	
 ∣; опасность всех переходов в пути суммируется. Выясните, какова минимальная опасность пути из квадрата (1, \, 1)(1,1) в квадрат (m, \, n)(m,n).

Входные данные

В первой строке входного файла заданы два числа mm и nn через пробел (1 \le m, \, n \le 1001≤m,n≤100). В следующих nn строках записано по mm чисел в каждой; ii-ое число jj-ой из этих строк соответствует высоте квадрата (i, \, j(i,j). Все высоты - целые числа в диапазоне от 11 до 100100, включительно.

Выходные данные

Выведите в выходной файл одно число - минимальную опасность пути из квадрата (1, \, 1)(1,1) в квадрат (m, \, n)(m,n).

Sample Input 1:

2 2
1 1
1 1
Sample Output 1:

0
Sample Input 2:

4 2
1 2 3 5
3 8 4 7
Sample Output 2:

6

*/
#include <bits/stdc++.h>

using namespace std;


int main() {
    int n, m;
    cin >> m >> n;
    if (m == 0) {
        cout << 1; // corner case 
        return 0;    
    }
    vector<vector<long long>> arr(n, vector<long long>(m));
    vector<vector<long long>> dp(n, vector<long long>(m));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cin >> arr[i][j];
        }
    }
    dp[0][0] = 0;
    for (int i = 1; i < m; ++i) {
        dp[0][i] = dp[0][i - 1] + abs(arr[0][i] - arr[0][i - 1]);
    }
    for (int i = 1; i < n; ++i) {
        dp[i][0] = dp[i - 1][0] + abs(arr[i][0] - arr[i - 1][0]);
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 1; j < m; ++j) {
            dp[i][j] = min(dp[i - 1][j] + abs(arr[i][j] - arr[i - 1][j]), dp[i][j - 1] + abs(arr[i][j] - arr[i][j - 1]));
        }
    }
    cout << dp[n - 1][m - 1];
    return 0;
}
