/*
https://stepik.org/lesson/307328/step/2?unit=289416


Черепашка

В верхнем-левом углу таблицы сидит черепаха. Она умеет ходить только вниз, вправо и вниз-вправо. В каждой клетке записано число, и черепашка прибавляет его к своей сумме, когда оказывается на клетке. Черепаха хочет попасть в нижнюю-правую клетку, получив в итоге минимально возможную сумму. Помогите ей - посчитайте, какую сумму она в итоге наберет?

Входные данные

В первой строке входных данных записано два числа nn, mm (1 \leq n, m \leq 10001≤n,m≤1000) - количество строк и столбцов в таблице.

В следующих nn строках записано по mm чисел - данная таблица. Каждое число в таблице по модулю не превышает 10001000. 

Выходные данные

В первой строке выведите два числа - минимальную возможную сумму, а также количество клеток qq, которое необходимо посетить чтобы набрать эту сумму.

Далее выведите qq строк, в каждой строке два числа - номер строки и номер столбца очередной посещенной клетки. Для любых двух подряд идущих клеток должно быть выполненно, что из первой можно попасть во вторую ходом черепашки. Также первая клетка должна быть верхней левой, а последняя - нижней правой. Если существует несколько способов добраться до нижней правой клеткой, набрав оптимальную сумму - выведите любой.

Sample Input 1:

4 4
1 3 5 2
-1 4 2 9
5 -6 1 -4
-6 6 -2 2
Sample Output 1:

-7 6
1 1
2 1
3 2
3 3
3 4
4 4
Sample Input 2:

2 4
1 2 3 4
5 6 7 8
Sample Output 2:

14 4
1 1
1 2
1 3
2 4
*/


#include <bits/stdc++.h>

using namespace std;

const long long MOD = 1000000123;

int main() {
    
    int n, m;
    cin >> n >> m;
    vector<vector<long long>> v(n, vector<long long>(m));
    vector<vector<long long>> dp(n, vector<long long>(m));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cin >> v[i][j];
        }
    }
    dp[0][0] = v[0][0];
    for (int i = 1; i < n; ++i) {
        dp[i][0] = dp[i - 1][0] + v[i][0];
    }
    for (int i = 1; i < m; ++i) {
        dp[0][i] = dp[0][i - 1] + v[0][i];
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 1; j < m; ++j) {
            dp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + v[i][j];
        }
    }

    vector<pair<int, int>> ans;
    int x = n - 1, y = m - 1;
    while (x >= 0 and y >= 0) {
        ans.push_back({x, y});
        if (x > 0 and dp[x][y] == dp[x - 1][y] + v[x][y]) {
            --x;
        } else if (y > 0 and dp[x][y] == dp[x][y - 1] + v[x][y]) {
            --y;
        } else {
            x--;
            y--;
        }
    }
    // Answer: Min cost and len
    cout << dp[n - 1][m - 1] << ' ' << ans.size() << endl;
    // Way
    for (int i = ans.size() - 1; i >= 0; --i) {
        cout << ans[i].first + 1 << ' ' << ans[i].second + 1 << endl;
    }
    

}
