/*
https://stepik.org/lesson/307328/step/3?unit=289416

Перед клетчатой полоской длины nn сидит кузнечик. В каждой клетке написано целое число. Когда кузнечик оказывается в какой-то клетке, ему дают конфет в том количестве, которое записано в этой клетке. Кузнечик умеет прыгать на следующую ступеньку, через две и через четыре ступеньки. То есть, если кузнечик сидит в клетке с номером ii, то за один шаг он может оказаться в клетках с номерами i + 1i+1, i + 3i+3, i + 5i+5. Помогите кузнечику - определите, какое максимальное количество конфет он может съесть, если в итоге должен оказаться в последней клетке? Обратите внимание, количество конфет может быть отрицательно.

Входные данные

В первой стркое записано единственное целое число nn (1 \leq n \leq 10^51≤n≤10 
5
 ) - длина полоски.

Во второй строке записано nn целых чисел a_ia 
i
​	
  (-10^9 \leq a_i \leq 10^9−10 
9
 ≤a 
i
​	
 ≤10 
9
 ) - количество конфет в каждой клетке.

Выходные данные

В первой строке выведите два числа - максимально возможную сумму, а также количество клеток qq, которое необходимо посетить чтобы набрать эту сумму.

Далее выведите строку, состоящую из qq чисел - номер очередной посещенной кузнечиком клетки. Для любых двух подряд идущих клеток должно быть выполненно, что из первой можно попасть во вторую ходом кузнечика. Самая первая клетка должна быть достижима из нулевой, а последняя должна быть самой правой. Если существует несколько способов добраться до правой клетки, набрав оптимальную сумму - выведите любой.

Sample Input 1:

5
4 7 6 6 6
Sample Output 1:

29 5
1 2 3 4 5
Sample Input 2:

10
-4 -4 -5 -2 1 3 1 2 -4 -3
Sample Output 2:

2 4
5 6 7 10

*/



#include <bits/stdc++.h>

using namespace std;


int main() {
    int n;
    cin >> n;
    vector<int> v(n);
    vector<long long> dp(n+1);
    for (int i = 0; i < n; ++i) {
        cin >> v[i];
    }
    dp[0] = 0;
    for (int i = 1; i <= n; ++i) {
        long long curMax = dp[i - 1];
        if (i > 2) {
            curMax = max(curMax, dp[i - 3]);
        }
        if (i > 4) {
            curMax = max(curMax, dp[i - 5]);
        }
        dp[i] = curMax + v[i - 1];
    }
    vector<int> way{n};
    int i = n;
    while (i > 0) {
        if (i - 1 >= 0 and dp[i] == dp[i - 1] + v[i-1]) {
            way.push_back(i - 1);
            --i;
        } else if (i - 3 >= 0 and dp[i] == dp[i - 3] + v[i-1]) {
            way.push_back(i - 3);
            i -= 3;
        } else if (i - 5 >= 0) {
            way.push_back(i - 5);
            i -= 5;
        } else {
            break;
        }
    }
    // Print result (max score and best_way
    if (way.back() == 0) {
        way.pop_back();
    }
    cout << dp[n] << ' ' << way.size() << endl;
    for (int i = way.size() - 1; i >= 0; --i) {
        cout << way[i] << ' ';
    }

}
